{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-95be8d54bd31d3ce27d17061327caadb40bca611",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/CardGame.sol": "project/contracts/CardGame.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/CardGame.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract CardGame {\n    struct Card {\n        uint attack;\n    }\n    \n    struct Player {\n        uint[] deck;\n        uint team; // 1 or 2\n        bool hasJoined;\n    }\n\n    // Config\n    mapping(uint => Card) public cards;\n    uint public constant MAX_HP = 100;\n    uint256 public constant ENTRY_FEE = 0.0067 ether; \n    \n    // State\n    uint public gameId; \n    mapping(uint => address) public redPlayer;\n    mapping(uint => address) public bluePlayer;\n    mapping(uint => mapping(address => Player)) public players; \n\n    mapping(uint => uint) public teamHP;   \n    mapping(uint => uint) public teamCards; \n\n    // Betting\n    mapping(uint => uint256) public gamePrizePool;      \n    \n    uint public currentTeamTurn; \n    bool public gameActive;\n    uint public winnerTeam;\n\n    event GameStarted(uint gameId);\n    event PlayerJoined(uint gameId, address player, uint team);\n    event CardPlayed(address player, uint team, uint cardId, uint damage);\n    event GameEnded(uint winningTeam, uint256 totalPrize);\n    event PayoutSent(address player, uint256 amount);\n    event GameCompleted(\n        uint256 gameId,\n        address winner,\n        uint256 totalPool,\n        uint256 fee,\n        uint256 payout,\n        bytes32 txHash,\n        uint256 timestamp\n    );\n\n    address public PLATFORM_TREASURY;\n    address public constant OWNER_WALLET = 0x0007c93EB56B0e3B81F5632b26499356501BFdE5;\n\n    constructor(address _treasury) {\n        // Route all platform fees to the owner wallet, regardless of the constructor arg\n        PLATFORM_TREASURY = OWNER_WALLET;\n        cards[0] = Card(5);\n        cards[1] = Card(8);\n        cards[2] = Card(3);\n        cards[3] = Card(12);\n        cards[4] = Card(6);\n        gameId = 1; \n    }\n\n    function joinGame() public payable {\n        // Automatically roll over to a new game if the current one is active,\n        // already has two players, or was previously completed.\n        if (\n            gameActive ||\n            winnerTeam != 0 ||\n            (redPlayer[gameId] != address(0) && bluePlayer[gameId] != address(0))\n        ) {\n            _startNewGame();\n        }\n\n        // Allow >= ENTRY_FEE to avoid precision issues from some wallets\n        require(msg.value >= ENTRY_FEE, \"Entry Fee too low\");\n        require(!players[gameId][msg.sender].hasJoined, \"Already joined this game\");\n\n        uint team;\n        address red = redPlayer[gameId];\n        address blue = bluePlayer[gameId];\n\n        if (red == address(0) && blue == address(0)) {\n            // First player joins this gameId: randomly assign Red or Blue\n            uint256 rand = uint256(\n                keccak256(\n                    abi.encodePacked(block.timestamp, msg.sender, block.prevrandao, gameId)\n                )\n            ) % 2;\n            if (rand == 0) {\n                team = 1;\n                redPlayer[gameId] = msg.sender;\n            } else {\n                team = 2;\n                bluePlayer[gameId] = msg.sender;\n            }\n        } else if (red == address(0)) {\n            // Only Red empty, assign current joiner to Red\n            team = 1;\n            redPlayer[gameId] = msg.sender;\n        } else if (blue == address(0)) {\n            // Only Blue empty, assign current joiner to Blue\n            team = 2;\n            bluePlayer[gameId] = msg.sender;\n        } else {\n            revert(\"Game is full - only 2 players allowed\");\n        }\n\n        players[gameId][msg.sender] = Player({\n            deck: new uint[](0), // Empty deck initially\n            team: team,\n            hasJoined: true\n        });\n\n        // Add to Pot\n        gamePrizePool[gameId] += msg.value;\n\n        emit PlayerJoined(gameId, msg.sender, team);\n\n        // Auto-start when both players are present\n        if (redPlayer[gameId] != address(0) && bluePlayer[gameId] != address(0)) {\n            startGame();\n        }\n    }\n\n    // Start the game - requires exactly 2 players\n    function startGame() public {\n        require(!gameActive, \"Game already active\");\n        require(redPlayer[gameId] != address(0) && bluePlayer[gameId] != address(0), \"Need exactly 2 players to start\");\n        \n        // Deal 5 cards to each player\n        _dealCards(redPlayer[gameId], 5);\n        _dealCards(bluePlayer[gameId], 5);\n\n        teamHP[1] = MAX_HP; // Red team HP\n        teamHP[2] = MAX_HP; // Blue team HP\n        teamCards[1] = 5;\n        teamCards[2] = 5;\n        currentTeamTurn = 1; \n        gameActive = true;\n        winnerTeam = 0;\n\n        emit GameStarted(gameId);\n    }\n\n    function _dealCards(address player, uint count) internal {\n        uint[] memory newDeck = new uint[](count);\n        uint256 seed = uint256(keccak256(abi.encodePacked(block.timestamp, player, block.number, gameId)));\n        for (uint i = 0; i < count; i++) {\n            newDeck[i] = uint256(keccak256(abi.encodePacked(seed, i))) % 5;\n        }\n        players[gameId][player].deck = newDeck;\n    }\n\n    function resetGame() public {\n        _startNewGame();\n    }\n\n    // Internal helper to cleanly move to the next gameId\n    function _startNewGame() internal {\n        gameId += 1;\n\n        // Reset per-game state for the new game\n        gameActive = false;\n        winnerTeam = 0;\n        currentTeamTurn = 1;\n\n        // Reset team HP and card counts for the upcoming game\n        teamHP[1] = 0;\n        teamHP[2] = 0;\n        teamCards[1] = 0;\n        teamCards[2] = 0;\n    }\n\n    function playCard(uint index) public {\n        require(gameActive, \"Game not active\");\n        Player storage p = players[gameId][msg.sender];\n        require(p.hasJoined, \"Not joined\");\n        require(p.team == currentTeamTurn, \"Not your team's turn\");\n        require(index < p.deck.length, \"Invalid card index\");\n\n        uint cardId = p.deck[index];\n        uint damage = cards[cardId].attack;\n\n        uint opponentTeam = (p.team == 1) ? 2 : 1;\n        if (teamHP[opponentTeam] <= damage) {\n            teamHP[opponentTeam] = 0;\n            finishGame(p.team, msg.sender);\n            return;\n        } else {\n            teamHP[opponentTeam] -= damage;\n        }\n\n        emit CardPlayed(msg.sender, p.team, cardId, damage);\n\n        p.deck[index] = p.deck[p.deck.length - 1];\n        p.deck.pop();\n        teamCards[p.team]--; \n\n        if (teamCards[opponentTeam] == 0) {\n            if (teamCards[p.team] > 0) {\n                finishGame(p.team, msg.sender);\n                return;\n            } else {\n                if (teamHP[p.team] >= teamHP[opponentTeam]) {\n                    finishGame(p.team, msg.sender); \n                } else {\n                    finishGame(opponentTeam, msg.sender); \n                }\n                return;\n            }\n        }\n\n        currentTeamTurn = opponentTeam;\n    }\n    \n    function finishGame(uint winner, address winnerAddress) internal {\n        gameActive = false;\n        winnerTeam = winner;\n        \n        uint256 totalPool = gamePrizePool[gameId];\n        if (totalPool > 0 && winnerAddress != address(0)) {\n            uint256 fee = (totalPool * 3) / 100;\n            uint256 payout = totalPool - fee;\n            payable(winnerAddress).transfer(payout);\n            emit PayoutSent(winnerAddress, payout);\n            // Send the platform fee to the owner wallet\n            payable(OWNER_WALLET).transfer(fee);\n            emit PayoutSent(OWNER_WALLET, fee);\n        }\n\n        emit GameEnded(winner, totalPool);\n        emit GameCompleted(\n            gameId,\n            winnerAddress,\n            totalPool,\n            (totalPool * 3) / 100,\n            totalPool - ((totalPool * 3) / 100),\n            bytes32(0),\n            block.timestamp\n        );\n    }\n\n    function getMyDeck() public view returns (uint[] memory) {\n        return players[gameId][msg.sender].deck;\n    }\n\n    function getGameState() public view returns (\n        bool active,\n        uint turn,\n        uint winner,\n        uint hp1,\n        uint hp2,\n        uint count1,\n        uint count2,\n        uint cards1,\n        uint cards2,\n        uint currentGameId,\n        uint256 prizePool \n    ) {\n        uint c1 = redPlayer[gameId] != address(0) ? 1 : 0;\n        uint c2 = bluePlayer[gameId] != address(0) ? 1 : 0;\n        return (\n            gameActive,\n            currentTeamTurn,\n            winnerTeam,\n            teamHP[1],\n            teamHP[2],\n            c1,\n            c2,\n            teamCards[1],\n            teamCards[2],\n            gameId,\n            gamePrizePool[gameId]\n        );\n    }\n}\n"
      }
    }
  }
}